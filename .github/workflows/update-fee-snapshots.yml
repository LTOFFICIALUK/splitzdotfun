name: Update Fee Snapshots

on:
  schedule:
    # Run every 5 minutes
    - cron: '*/5 * * * *'
  workflow_dispatch: # Allow manual trigger

# Prevent overlapping runs
concurrency:
  group: update-fee-snapshots
  cancel-in-progress: false

jobs:
  update-snapshots:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'
        
    - name: Install dependencies
      run: npm ci
      
    - name: Run fee snapshot update
      env:
        SUPABASE_SERVICE_ROLE_KEY: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}
        BAGS_API_KEY: ${{ secrets.BAGS_API_KEY }}
        SOLANA_RPC_URL: ${{ secrets.SOLANA_RPC_URL }}
        NEXT_PUBLIC_SUPABASE_URL: ${{ secrets.NEXT_PUBLIC_SUPABASE_URL }}
      run: |
        # Create a temporary script to run the fee snapshot update
        cat > update-fees.js << 'EOF'
        const { createClient } = require('@supabase/supabase-js');
        const fetch = require('node-fetch');

        const supabase = createClient(
          process.env.NEXT_PUBLIC_SUPABASE_URL,
          process.env.SUPABASE_SERVICE_ROLE_KEY
        );

        async function getLifetimeFees(tokenMint) {
          try {
            const response = await fetch(
              `https://public-api-v2.bags.fm/api/v1/token-launch/lifetime-fees?tokenMint=${tokenMint}`,
              {
                headers: {
                  'x-api-key': process.env.BAGS_API_KEY
                }
              }
            );
            
            if (!response.ok) {
              throw new Error(`Bags API error: ${response.status}`);
            }
            
            const data = await response.json();
            return data.response; // The response contains the lifetime fees value
          } catch (error) {
            console.error(`Error fetching lifetime fees for ${tokenMint}:`, error);
            return null;
          }
        }

        async function updateFeeSnapshots() {
          try {
            console.log('üîÑ Starting fee snapshot update job...');
            
            // Record job start
            const { data: jobRun, error: jobError } = await supabase
              .from('job_runs')
              .insert({
                job_name: 'update-fee-snapshots',
                started_at: new Date().toISOString(),
                status: 'running'
              })
              .select()
              .single();

            if (jobError) {
              console.error('‚ùå Failed to create job run:', jobError);
              process.exit(1);
            }

            const jobRunId = jobRun.id;
            let tokensProcessed = 0;
            let snapshotsWritten = 0;
            let startTime = Date.now();

            // Get all tokens
            const { data: tokens, error: tokensError } = await supabase
              .from('tokens')
              .select('id, contract_address')
              .not('contract_address', 'is', null);

            if (tokensError) {
              throw new Error(`Failed to fetch tokens: ${tokensError.message}`);
            }

            console.log(`üìä Processing ${tokens.length} tokens...`);

            for (const token of tokens) {
              try {
                // Get current lifetime fees from Bags API
                const lifetimeFeesResponse = await getLifetimeFees(token.contract_address);
                
                if (!lifetimeFeesResponse) {
                  console.warn(`‚ö†Ô∏è No lifetime fees data for token ${token.contract_address}`);
                  continue;
                }

                const lifetimeFees = parseFloat(lifetimeFeesResponse);
                if (isNaN(lifetimeFees)) {
                  console.warn(`‚ö†Ô∏è Invalid lifetime fees value for token ${token.contract_address}: ${lifetimeFeesResponse}`);
                  continue;
                }

                const lifetimeFeesLamports = Math.floor(lifetimeFees * 1e9); // Convert SOL to lamports

                // Get the last snapshot for this token
                const { data: lastSnapshot } = await supabase
                  .from('token_fee_snapshots')
                  .select('lifetime_fees_lamports_after')
                  .eq('token_id', token.id)
                  .order('lifetime_fees_lamports_after', { ascending: false })
                  .limit(1)
                  .single();

                const lastFees = lastSnapshot?.lifetime_fees_lamports_after || 0;

                // Only process if there's an increase
                if (lifetimeFeesLamports > lastFees) {
                  const delta = lifetimeFeesLamports - lastFees;
                  console.log(`üí∞ Token ${token.contract_address}: +${delta} lamports (${delta / 1e9} SOL)`);

                  // Insert new snapshot
                  const { data: snapshot, error: snapshotError } = await supabase
                    .from('token_fee_snapshots')
                    .insert({
                      token_id: token.id,
                      lifetime_fees_lamports_after: lifetimeFeesLamports,
                      job_run_id: jobRunId,
                      source_ref: `bags_lifetime_${Date.now()}`
                    })
                    .select()
                    .single();

                  if (snapshotError) {
                    console.error(`‚ùå Failed to insert snapshot for token ${token.id}:`, snapshotError);
                    continue;
                  }

                  snapshotsWritten++;

                  // Get active royalty agreement for this token
                  const { data: activeAgreement } = await supabase
                    .from('royalty_agreement_versions')
                    .select(`
                      id,
                      platform_fee_bps,
                      royalty_agreement_version_shares (
                        earner_wallet,
                        bps
                      )
                    `)
                    .eq('token_id', token.id)
                    .is('effective_to', null)
                    .single();

                  if (!activeAgreement) {
                    console.warn(`‚ö†Ô∏è No active royalty agreement for token ${token.id}`);
                    continue;
                  }

                  // Calculate fee distribution
                  const platformBps = activeAgreement.platform_fee_bps;
                  const platformDelta = Math.floor(delta * platformBps / 10000);
                  const earnersDelta = delta - platformDelta;

                  // Insert platform accrual
                  await supabase
                    .from('fee_accrual_ledger')
                    .insert({
                      token_id: token.id,
                      entry_type: 'ACCRUAL',
                      beneficiary_kind: 'PLATFORM',
                      beneficiary_wallet: null,
                      amount_lamports: platformDelta,
                      related_snapshot_id: snapshot.id,
                      agreement_version_id: activeAgreement.id
                    });

                  // Insert earner accruals
                  for (const share of activeAgreement.royalty_agreement_version_shares) {
                    const earnerDelta = Math.floor(earnersDelta * share.bps / (10000 - platformBps));
                    
                    await supabase
                      .from('fee_accrual_ledger')
                      .insert({
                        token_id: token.id,
                        entry_type: 'ACCRUAL',
                        beneficiary_kind: 'EARNER',
                        beneficiary_wallet: share.earner_wallet,
                        amount_lamports: earnerDelta,
                        related_snapshot_id: snapshot.id,
                        agreement_version_id: activeAgreement.id
                      });
                  }

                  tokensProcessed++;
                }
              } catch (tokenError) {
                console.error(`‚ùå Error processing token ${token.contract_address}:`, tokenError);
                continue;
              }
            }

            // Update job run with success
            await supabase
              .from('job_runs')
              .update({
                finished_at: new Date().toISOString(),
                status: 'success',
                tokens_processed: tokensProcessed,
                snapshots_written: snapshotsWritten,
                view_refresh_ms: Date.now() - startTime
              })
              .eq('id', jobRunId);

            console.log(`‚úÖ Fee snapshot update completed successfully!`);
            console.log(`üìä Tokens processed: ${tokensProcessed}`);
            console.log(`üì∏ Snapshots written: ${snapshotsWritten}`);
            console.log(`‚è±Ô∏è Duration: ${Date.now() - startTime}ms`);

          } catch (error) {
            console.error('‚ùå Fee snapshot update failed:', error);
            process.exit(1);
          }
        }

        updateFeeSnapshots();
        EOF

        # Run the script
        node update-fees.js
          
    - name: Handle success
      if: success()
      run: |
        echo "‚úÖ Fee snapshots updated successfully"
        echo "Timestamp: $(date)"
        
    - name: Handle failure
      if: failure()
      run: |
        echo "‚ùå Fee snapshot update failed"
        echo "Timestamp: $(date)"
        # You can add notifications here (Slack, Discord, etc.)
