name: Claim Fees from Bags

on:
  schedule:
    # Run every hour
    - cron: '0 * * * *'
  workflow_dispatch: # Allow manual trigger

# Prevent overlapping runs
concurrency:
  group: claim-fees
  cancel-in-progress: false

jobs:
  claim-fees:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'
        
    - name: Install dependencies
      run: npm ci
      
    - name: Run fee claiming
      env:
        SUPABASE_SERVICE_ROLE_KEY: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}
        BAGS_API_KEY: ${{ secrets.BAGS_API_KEY }}
        SOLANA_RPC_URL: ${{ secrets.SOLANA_RPC_URL }}
        NEXT_PUBLIC_SUPABASE_URL: ${{ secrets.NEXT_PUBLIC_SUPABASE_URL }}
        TREASURY_WALLET_ADDRESS: ${{ secrets.TREASURY_WALLET_ADDRESS }}
        TREASURY_PRIVATE_KEY: ${{ secrets.TREASURY_PRIVATE_KEY }}
        SOLANA_COMMITMENT: ${{ secrets.SOLANA_COMMITMENT }}
      run: |
        # Create a temporary script to run the fee claiming
        cat > claim-fees.js << 'EOF'
        const { createClient } = require('@supabase/supabase-js');
        const fetch = require('node-fetch');
        const { Connection, Keypair, Transaction, PublicKey } = require('@solana/web3.js');
        const bs58 = require('bs58');

        const supabase = createClient(
          process.env.NEXT_PUBLIC_SUPABASE_URL,
          process.env.SUPABASE_SERVICE_ROLE_KEY
        );

        const connection = new Connection(process.env.SOLANA_RPC_URL, process.env.SOLANA_COMMITMENT || 'confirmed');
        const treasuryKeypair = Keypair.fromSecretKey(bs58.decode(process.env.TREASURY_PRIVATE_KEY));
        const treasuryWallet = new PublicKey(process.env.TREASURY_WALLET_ADDRESS);

        async function getFeeShareWallets() {
          try {
            console.log('üîç Fetching tokens with royalty earners...');
            
            // Get all tokens
            const { data: tokens, error: tokenError } = await supabase
              .from('tokens')
              .select('id, contract_address, name');

            if (tokenError) {
              console.error('‚ùå Error fetching tokens:', tokenError);
              return [];
            }

            console.log(`üìä Found ${tokens.length} tokens`);

            // Get all token ownership records with royalty earners
            const { data: ownershipRecords, error: ownershipRecordsError } = await supabase
              .from('token_ownership')
              .select('token_id, royalty_earners')
              .not('royalty_earners', 'is', null);

            if (ownershipRecordsError) {
              console.error('‚ùå Error fetching ownership records:', ownershipRecordsError);
              return [];
            }

            console.log(`üìä Found ${ownershipRecords.length} ownership records with royalty earners`);

            // Create a map of token_id to ownership data
            const ownershipMap = {};
            ownershipRecords.forEach(record => {
              ownershipMap[record.token_id] = record.royalty_earners;
            });

            // Filter tokens that have ownership records with royalty earners
            const tokensWithRoyalties = tokens.filter(token => ownershipMap[token.id]);
            console.log(`üìä Found ${tokensWithRoyalties.length} tokens with royalty earners`);

            // Add ownership data to tokens
            const tokensWithData = tokensWithRoyalties.map(token => ({
              ...token,
              token_ownership: {
                royalty_earners: ownershipMap[token.id]
              }
            }));

            const feeShareWallets = [];

            for (const token of tokensWithData) {
              try {
                console.log(`üîç Processing token: ${token.name} (${token.contract_address})`);
                
                let royaltyEarners = token.token_ownership.royalty_earners;
                console.log(`üìÑ Raw royalty_earners:`, royaltyEarners);
                
                // Parse JSON if it's a string
                if (typeof royaltyEarners === 'string') {
                  try {
                    royaltyEarners = JSON.parse(royaltyEarners);
                    console.log(`‚úÖ Parsed JSON successfully:`, royaltyEarners);
                  } catch (parseError) {
                    console.error(`‚ùå Failed to parse royalty_earners for token ${token.name}:`, parseError);
                    continue;
                  }
                }
                
                // Ensure it's an array
                if (!Array.isArray(royaltyEarners)) {
                  console.warn(`‚ö†Ô∏è royalty_earners is not an array for token ${token.name}:`, royaltyEarners);
                  continue;
                }
                
                console.log(`üìã Found ${royaltyEarners.length} royalty earners`);
                
                for (const earner of royaltyEarners) {
                  console.log(`üë§ Processing earner:`, earner);
                  
                  if (earner.social_or_wallet && earner.social_or_wallet.startsWith('@')) {
                    console.log(`üê¶ Getting wallet for social handle: ${earner.social_or_wallet}`);
                    
                    // Get wallet address for social handle
                    const response = await fetch(
                      `https://public-api-v2.bags.fm/api/v1/token-launch/fee-share/wallet/twitter?twitterUsername=${earner.social_or_wallet.substring(1)}`,
                      {
                        headers: {
                          'x-api-key': process.env.BAGS_API_KEY
                        }
                      }
                    );
                    
                    if (response.ok) {
                      const data = await response.json();
                      const walletAddress = data.response;
                      
                      if (walletAddress) {
                        console.log(`‚úÖ Got wallet address: ${walletAddress}`);
                        feeShareWallets.push({
                          token_id: token.id,
                          token_mint: token.contract_address,
                          token_name: token.name,
                          earner_wallet: walletAddress,
                          earner_social: earner.social_or_wallet,
                          percentage: earner.percentage
                        });
                      }
                    }
                  } else if (earner.social_or_wallet && !earner.social_or_wallet.startsWith('@')) {
                    // Direct wallet address
                    console.log(`üí≥ Direct wallet address: ${earner.social_or_wallet}`);
                    feeShareWallets.push({
                      token_id: token.id,
                      token_mint: token.contract_address,
                      token_name: token.name,
                      earner_wallet: earner.social_or_wallet,
                      earner_social: null,
                      percentage: earner.percentage
                    });
                  }
                }
              } catch (tokenError) {
                console.error(`‚ùå Error processing token ${token.name}:`, tokenError);
                continue;
              }
            }

            console.log(`üìä Total fee share wallets found: ${feeShareWallets.length}`);
            return feeShareWallets;

            // Add treasury wallet for platform fees (only if you want to claim platform fees)
            // feeShareWallets.push({
            //   token_id: 'treasury',
            //   token_mint: 'treasury',
            //   token_name: 'Platform Fees',
            //   earner_wallet: process.env.TREASURY_WALLET_ADDRESS,
            //   earner_social: 'Platform',
            //   percentage: 20
            // });

            return feeShareWallets;
          } catch (error) {
            console.error('Error fetching fee share wallets:', error);
            return [];
          }
        }

        async function getClaimTransaction(position) {
          try {
            console.log(`üîç Getting pool config for feeClaimer: ${position.feeClaimer}`);
            console.log(`üîç Token mint: ${position.tokenMint}`);
            
            // For royalty earners, we need to get the pool config first
            const poolConfigResponse = await fetch(
              'https://public-api-v2.bags.fm/api/v1/state/pool-config-keys-by-fee-claimer-vaults',
              {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'x-api-key': process.env.BAGS_API_KEY
                },
                body: JSON.stringify({
                  feeClaimer: position.feeClaimer
                })
              }
            );
            
            if (!poolConfigResponse.ok) {
              console.error(`‚ùå Pool config error: ${poolConfigResponse.status}`);
              const errorText = await poolConfigResponse.text();
              console.error(`‚ùå Error details: ${errorText}`);
              return null;
            }
            
            const poolConfigData = await poolConfigResponse.json();
            const poolConfigs = poolConfigData.response || [];
            
            console.log(`üìä Found ${poolConfigs.length} pool configs for feeClaimer ${position.feeClaimer}`);
            console.log(`üîç Looking for token mint: ${position.tokenMint}`);
            
            // Find the pool config for this specific token
            const tokenPoolConfig = poolConfigs.find(config => 
              config.tokenMint === position.tokenMint
            );
            
            if (!tokenPoolConfig) {
              console.warn(`‚ö†Ô∏è No pool config found for token ${position.tokenMint}`);
              console.log(`üìã Available token mints:`, poolConfigs.map(c => c.tokenMint));
              return null;
            }
            
            console.log(`‚úÖ Found pool config for token ${position.tokenMint}`);
            
            // Generate claim transaction with the pool config data
            const response = await fetch(
              'https://public-api-v2.bags.fm/api/v1/token-launch/claim-txs',
              {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'x-api-key': process.env.BAGS_API_KEY
                },
                body: JSON.stringify({
                  feeClaimer: position.feeClaimer,
                  tokenMint: position.tokenMint,
                  virtualPoolAddress: tokenPoolConfig.virtualPoolAddress,
                  dammV2Position: tokenPoolConfig.dammV2Position,
                  dammV2Pool: tokenPoolConfig.dammV2Pool,
                  dammV2PositionNftAccount: tokenPoolConfig.dammV2PositionNftAccount,
                  tokenAMint: tokenPoolConfig.tokenAMint,
                  tokenBMint: tokenPoolConfig.tokenBMint,
                  tokenAVault: tokenPoolConfig.tokenAVault,
                  tokenBVault: tokenPoolConfig.tokenBVault,
                  claimVirtualPoolFees: true,
                  claimDammV2Fees: true,
                  isCustomFeeVault: tokenPoolConfig.isCustomFeeVault || false,
                  customFeeVaultClaimerA: tokenPoolConfig.customFeeVaultClaimerA,
                  customFeeVaultClaimerB: tokenPoolConfig.customFeeVaultClaimerB,
                  customFeeVaultClaimerSide: tokenPoolConfig.customFeeVaultClaimerSide
                })
              }
            );
            
            if (!response.ok) {
              throw new Error(`Bags API error: ${response.status}`);
            }
            
            const data = await response.json();
            return data.response[0]?.tx; // Return the transaction data
          } catch (error) {
            console.error('Error getting claim transaction:', error);
            return null;
          }
        }

        async function sendAndConfirmTransaction(transactionData) {
          try {
            // Deserialize the transaction
            const transaction = Transaction.from(Buffer.from(transactionData, 'base64'));
            
            // Sign the transaction
            transaction.sign(treasuryKeypair);
            
            // Send the transaction
            const signature = await connection.sendTransaction(transaction, [treasuryKeypair], {
              skipPreflight: true,
              maxRetries: 3
            });
            
            console.log(`üì§ Transaction sent: ${signature}`);
            
            // Wait for confirmation
            const confirmation = await connection.confirmTransaction(signature, process.env.SOLANA_COMMITMENT || 'confirmed');
            
            if (confirmation.value.err) {
              throw new Error(`Transaction failed: ${confirmation.value.err}`);
            }
            
            console.log(`‚úÖ Transaction confirmed: ${signature}`);
            return signature;
          } catch (error) {
            console.error('Error sending transaction:', error);
            return null;
          }
        }

        async function claimFees() {
          try {
            console.log('üîÑ Starting fee claiming job...');
            
            // Record job start
            const { data: jobRun, error: jobError } = await supabase
              .from('job_runs')
              .insert({
                job_name: 'claim-fees',
                started_at: new Date().toISOString(),
                status: 'running'
              })
              .select()
              .single();

            if (jobError) {
              console.error('‚ùå Failed to create job run:', jobError);
              process.exit(1);
            }

            const jobRunId = jobRun.id;
            let claimsProcessed = 0;
            let totalClaimedLamports = 0;
            let startTime = Date.now();

            // Get fee share wallets for all tokens
            const feeShareWallets = await getFeeShareWallets();
            console.log(`üìä Found ${feeShareWallets.length} fee share wallets`);

            for (const wallet of feeShareWallets) {
              try {
                console.log(`üí∞ Testing wallet: ${wallet.earner_wallet} for token: ${wallet.token_name}`);
                console.log(`üí∞ Claiming fees for wallet ${wallet.earner_wallet} and token ${wallet.token_mint}`);
                console.log(`üîç Token details: ${wallet.token_name} (${wallet.token_mint})`);
                console.log(`üë§ Wallet: ${wallet.earner_wallet}`);
                console.log(`üìä Percentage: ${wallet.percentage}%`);
                
                // Get claim transaction for this wallet
                const claimTransaction = await getClaimTransaction({
                  feeClaimer: wallet.earner_wallet,
                  tokenMint: wallet.token_mint
                });
                
                if (!claimTransaction) {
                  console.warn(`‚ö†Ô∏è No claim transaction generated for wallet ${wallet.earner_wallet}`);
                  continue;
                }

                // Send and confirm transaction
                const signature = await sendAndConfirmTransaction(claimTransaction);
                if (!signature) {
                  console.error(`‚ùå Failed to send claim transaction for wallet ${wallet.earner_wallet}`);
                  continue;
                }

                // Get wallet balance before claim to calculate actual amount claimed
                const balanceBefore = await connection.getBalance(new PublicKey(wallet.earner_wallet));
                
                // Record claim in database (amount will be updated after transaction)
                const { data: bagsClaim, error: claimError } = await supabase
                  .from('bags_claims')
                  .insert({
                    token_id: wallet.token_id === 'treasury' ? null : wallet.token_id,
                    treasury_wallet: wallet.earner_wallet,
                    amount_lamports: 0, // Will be updated after transaction
                    tx_signature: signature,
                    status: 'confirmed',
                    occurred_at: new Date().toISOString()
                  })
                  .select()
                  .single();

                if (claimError) {
                  console.error(`‚ùå Failed to record claim:`, claimError);
                  continue;
                }

                // Wait a moment for transaction to settle, then get balance after
                await new Promise(resolve => setTimeout(resolve, 2000));
                const balanceAfter = await connection.getBalance(new PublicKey(wallet.earner_wallet));
                
                // Calculate actual amount claimed (accounting for transaction fees)
                const actualAmountClaimed = balanceAfter - balanceBefore;
                
                // Update the claim record with actual amount
                await supabase
                  .from('bags_claims')
                  .update({ amount_lamports: actualAmountClaimed })
                  .eq('id', bagsClaim.id);

                // Mirror to fee accrual ledger with actual amount
                await supabase
                  .from('fee_accrual_ledger')
                  .insert({
                    token_id: wallet.token_id === 'treasury' ? null : wallet.token_id,
                    entry_type: 'CLAIM_FROM_BAGS',
                    beneficiary_kind: wallet.token_id === 'treasury' ? 'TREASURY' : 'EARNER',
                    beneficiary_wallet: wallet.earner_wallet,
                    amount_lamports: actualAmountClaimed,
                    related_bags_claim_id: bagsClaim.id,
                    external_tx_signature: signature,
                    occurred_at: new Date().toISOString()
                  });

                claimsProcessed++;
                totalClaimedLamports += actualAmountClaimed;
                
                console.log(`‚úÖ Claimed ${actualAmountClaimed / 1e9} SOL for wallet ${wallet.earner_wallet}`);

              } catch (walletError) {
                console.error(`‚ùå Error processing wallet ${wallet.earner_wallet}:`, walletError);
                continue;
              }
            }

            // Update job run with success
            await supabase
              .from('job_runs')
              .update({
                finished_at: new Date().toISOString(),
                status: 'success',
                claims_processed: claimsProcessed,
                view_refresh_ms: Date.now() - startTime
              })
              .eq('id', jobRunId);

            console.log(`‚úÖ Fee claiming completed successfully!`);
            console.log(`üìä Claims processed: ${claimsProcessed}`);
            console.log(`üí∞ Total claimed: ${totalClaimedLamports / 1e9} SOL`);
            console.log(`‚è±Ô∏è Duration: ${Date.now() - startTime}ms`);

          } catch (error) {
            console.error('‚ùå Fee claiming failed:', error);
            process.exit(1);
          }
        }

        claimFees();
        EOF

        # Install additional dependencies
        npm install @solana/web3.js bs58

        # Run the script
        node claim-fees.js
          
    - name: Handle success
      if: success()
      run: |
        echo "‚úÖ Fee claiming completed successfully"
        echo "Timestamp: $(date)"
        
    - name: Handle failure
      if: failure()
      run: |
        echo "‚ùå Fee claiming failed"
        echo "Timestamp: $(date)"
        # You can add notifications here (Slack, Discord, etc.)
